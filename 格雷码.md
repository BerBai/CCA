格雷码是一个二进制数系，其中两个相邻数的二进制位只有一位不同。举个例子，$3$ 位二进制数的格雷码序列为 $000,001,011,010,110,111,101,100$。

注意序列的下标我们以 $0$ 为起点，也就是说 $G(0)=000,G(4)=110$。

格雷码由贝尔实验室的 Frank Gray 于 1940 年代提出，并于 1953 年获得专利。

## 构造格雷码（变换）

格雷码的构造方法很多。我们首先介绍手动构造方法，然后会给出构造的代码以及正确性证明。

### 手动构造

$k$ 位的格雷码可以通过以下方法构造。我们从全 $0$ 格雷码开始，按照下面策略：

1. 翻转最低位得到下一个格雷码，（例如 $000\to001$）；
2. 把最右边的 $1$ 的左边的位翻转得到下一个格雷码，（例如 $001\to011$）；

交替按照上述策略生成 $2^{k-1}$ 次，可得到 $k$ 位的格雷码序列。

### 镜像构造

$k$ 位的格雷码可以从 $k-1$ 位的格雷码以上下镜射后加上新位的方式快速得到，如下图：
![](格雷码%20镜像构造.png)
### 计算方法

我们观察一下 $n$ 的二进制和 $G(n)$。可以发现，如果 $G(n)$ 的二进制第 $i$ 位为 $1$，仅当 $n$ 的二进制第 $i$ 位为 $1$，第 $i+1$ 位为 $0$ 或者第 i 位为 $0$，第 $i+1$ 位为 $1$。于是我们可以当成一个异或运算 $G (n)=n \oplus \left \lfloor \frac{n}{2}  \right \rfloor$。

```
int g(int n)
{
	return n ^ (n >> 1);
}
```

### 正确性证明

接下来我们证明一下，按照上述公式生成的格雷码序列，相邻两个格雷码的二进制位有且仅有一位不同。

我们考虑 $n$ 和 $n+1$ 的区别。把 $n$ 加 $1$，相当于把 $n$ 的二进制下末位的连续的 $1$ 全部变成取反，然后把最低位的 $0$ 变成 $1$。我们这样表示 $n$ 和 $n+1$ 的二进制位：
$$
\begin{aligned}
(n)_2 &= \cdots 0\underbrace{11\cdots 11}_{k\text{个}}\\
(n+1)_2 &= \cdots 1\underbrace{00\cdots 00}_{k\text{个}}
\end{aligned}
$$
于是我们在计算 $g (n)$ 和 $g (n+1)$ 的时侯，后 $k$ 位都会变成 $\underbrace{100\cdots 00}_{k\text{个}}$ 的形式，而第 $k+1$ 位是不同的，因为 $n$ 和 $n+1$ 除了后 $k+1$ 位，其他位都是相同的。因此第 $k+1$ 位要么同时异或 $1$，要么同时异或 $0$。两种情况，第 $k+1$ 位都是不同的。而除了后 $k+1$ 位以外的二进制位也是做相同的异或运算，结果是相同的。

证毕。

### 通过格雷码构造原数 （逆变换）

接下来我们考虑格雷码的逆变换，即给你一个格雷码 $g$，要求你找到原数 $n$。我们考虑从二进制最高位遍历到最低位（最低位下标为 $1$，即个位；最高位下标为 $k$）。则 $n$ 的二进制第 $i$ 位与 $g$ 的二进制第 $i$ 位 $g_i$ 的关系如下：
$$\begin{aligned}
N_k &= g_k \\
N_{k-1} &= g_{k-1} \oplus n_k &&= g_k \oplus g_{k-1} \\
N_{k-2} &= g_{k-2} \oplus n_{k-1} &&= g_k \oplus g_{k-1} \oplus g_{k-2} \\
N_{k-3} &= g_{k-3} \oplus n_{k-2} &&= g_k \oplus g_{k-1} \oplus g_{k-2} \oplus g_{k-3} \\
&\vdots\\
N_{k-i} &=\displaystyle\bigoplus_{j=0}^ig_{k-j}
\end{aligned}$$
```
int rev_g (int g) 
{
	int n = 0;
	for (; g; g >>= 1) n ^= g;
	return n;
}
```

## 实际应用

格雷码有一些十分有用的应用，有些应用让人意想不到：

$k$ 位二进制数的格雷码序列可以当作 $k$ 维空间中的一个超立方体（二维里的正方形，一维里的单位向量）顶点的哈密尔顿回路，其中格雷码的每一位代表一个维度的坐标。

1. 格雷码被用于最小化数字模拟转换器（比如传感器）的信号传输中出现的错误，因为它每次只改变一个位。

2. 格雷码可以用来解决汉诺塔的问题。

设盘的数量为 $n$。我们从 $n$ 位全 $0$ 的格雷码 $G (0)$ 开始，依次移向下一个格雷码（$G (i)$ 移向 $G (i+1)$）。当前格雷码的二进制第 i 位表示从小到大第 $i$ 个盘子。

由于每一次只有一个二进制位会改变，因此当第 $i$ 位改变时，我们移动第 $i$ 个盘子。在移动盘子的过程中，除了最小的盘子，其他任意一个盘子在移动的时侯，只能有一个放置选择。在移动第一个盘子的时侯，我们总是有两个放置选择。于是我们的策略如下：

如果 $n$ 是一个奇数，那么盘子的移动路径为 $f\to t\to r\to f\to t\to r\to\cdots$，其中 f 是最开始的柱子，$t$ 是最终我们把所有盘子放到的柱子，$r$ 是中间的柱子。

如果 $n$ 是偶数：$f \to r \to t \to f \to r \to t \to \cdots$

3. 格雷码也在遗传算法理论中得到应用。


## 代码实现

```c
/******************* main.cpp *******************/  
  
#include <iostream>  
#include <vector>  
#include <math.h>  
#include <time.h>  
#include <string>  
#include "golay.h"  
#include <ctime>  
  
using namespace std;  
  
int main() {  
    system("chcp 65001");  
  
    matrix gen,gen_t,par,par_t,encoded_message,syndrome,  
            sB,s_add_colB,sB_add_colB_T,original_message;  
    matrix message(1,12);  
    matrix temp1(1,12);  
    matrix noise(1,24);  
    matrix error(1,24);  
    matrix s_add_colB_full(12,13);  
    matrix sB_add_colB_T_full(12,13);  
    matrix temp(12,1);  
  
    int i,j,k;  
    vector<int> zeros(24);  
  
    clock_t start = clock();  
  
    gen = golay_generator();   // 生成 Golay 24 码的生成矩阵  
    cout << "生成 Golay 24 码的生成矩阵（G）：" << endl;  
    print(gen);  
  
    gen_t = transpose(gen); // 生成矩阵 G 的转置  
    cout << endl << "生成矩阵转置（G^T）：" << endl;  
    print(gen_t);  
  
    par = generate_B();        // Golay 24 码的奇偶校验矩阵  
    cout << endl << "Golay 24 码的奇偶校验矩阵（B）：" << endl;  
    print(par);  
  
    par_t = transpose(par); // 奇偶校验矩阵 B 的转置  
    cout << endl << "奇偶校验矩阵转置（B^T）：" << endl;  
    print(par_t);  
  
    message = generate_message();   // 生成随机消息  
    cout << endl << "消息（m）：   ";  
    print(message);  
  
    encoded_message = encode(message,gen);  // 编码消息  
    cout << endl << "编码消息（mG）：  ";  
    print(encoded_message);  
  
    noise = noisy_channel(encoded_message); // 将消息发送到“有噪声的信道”  
    cout << endl << "接收到的消息（r = c + e）：  ";  
    print(noise);  
  
    syndrome = multiply(noise, gen_t);  // 计算 s = rG^T    cout << endl << "综合（s = rG^T）：   ";  
    print(syndrome);  
    cout << "综合的权重是 " << weight(syndrome) << endl;  
  
    sB = multiply(syndrome,par);    // 计算 sB    cout << endl << "sB：    ";  
    print(sB);  
    cout  << "sB 的权重是 " << weight(sB);  
  
    /* 计算行向量 s + (c_j)^T 并计算行向量的权重 */    for(i = 0 ; i < 12 ; i++) {  
        for(j = 0 ; j < 12 ; j++) {  
            temp.m[j][0] = par.m[j][i];  
        }  
  
        temp1 = transpose(temp);  
        s_add_colB = addition(syndrome,temp1);  
  
        for(k = 0 ; k < 13 ; k++) {  
            if(k < 12) {  
                s_add_colB_full.m[i][k] = s_add_colB.m[0][k];  
            } else {  
                s_add_colB_full.m[i][k] = weight(s_add_colB);  
            }  
        }  
    }  
  
    cout << "\n\n" << "完整的 s + (c_j)^T（最后一列的值是行的权重）：" << endl;  
    print(s_add_colB_full);  
  
    /* 计算行向量 sB + (b_j)^T 并计算行向量的权重 */    for(i = 0 ; i < 12 ; i++) {  
        for(j = 0 ; j < 12 ; j++) {  
            temp.m[j][0] = par_t.m[j][i];  
        }  
  
        temp1 = transpose(temp);  
        sB_add_colB_T = addition(sB,temp1);  
  
        for(k = 0 ; k < 13 ; k++) {  
            if(k < 12) {  
                sB_add_colB_T_full.m[i][k] = sB_add_colB_T.m[0][k];  
            } else {  
                sB_add_colB_T_full.m[i][k] = weight(sB_add_colB_T);  
            }  
        }  
    }  
  
    cout << "\n\n" << "完整的 sB + (b_j)^T（最后一列的值是行的权重）：" << endl;  
    print(sB_add_colB_T_full);  
  
    /***** 计算错误向量 e *****/    if(weight(syndrome) <= 3) {  
        for(i = 0; i < syndrome.m[0].size() ; i++) {  
            if(syndrome.m[0][i] == 1) {  
                error.m[0][i] = 1;  
            }  
        }  
    } else if(weight(sB) <= 3) {  
        for(i = 0; i < sB.m[0].size() ; i++) {  
            if(sB.m[0][i] == 1) {  
                error.m[0][i+12] = 1;  
            }  
        }  
    }  
  
    if(error.m[0] == zeros) {  
        for(i = 0; i < 12 ; i++) {  
            if(s_add_colB_full.m[i][12] <= 2) {  
                error.m[0][i+12] = 1;  
  
                for(j = 0 ; j< 12 ; j++) {  
                    if(s_add_colB_full.m[i][j] ==1) {  
                        error.m[0][j] = 1;  
                    }  
                }  
            }  
        }  
    }  
  
    if(error.m[0] == zeros) {  
        for(i = 0; i < 12 ; i++) {  
            if(sB_add_colB_T_full.m[i][12] <= 2) {  
                error.m[0][i] = 1;  
  
                for(j = 0 ; j< 12 ; j++) {  
                    if(sB_add_colB_T_full.m[i][j] ==1) {  
                        error.m[0][j+12] = 1;  
                    }  
                }  
            }  
        }  
    }  
  
    cout << endl <<"错误向量是：    ";  
    print(error);  
  
    original_message =addition(noise,error);    // 计算原始消息 c = r + e  
    /***** 检查解码是否正确 *****/    if(original_message.m == encoded_message.m) {  
        cout << endl << "传输和纠错成功。" << endl;  
    } else {  
        cout << "传输或纠错出现错误。" << endl;  
    }  
  
    cout << endl << "计算出的原始发送消息：   ";  
    print(original_message);  
    cout << "         原始发送消息：   ";  
    print(encoded_message);  
  
  
    cout << endl << "计算出的原始消息 m ：   ";  
    for(i = 0 ; i < 12 ; i++) {  
        cout << original_message.m[0][i] << "  ";  
    }  
    cout << endl << "         原始消息 m ：   ";  
    for(i = 0 ; i < 12 ; i++) {  
        cout << message.m[0][i] << "  ";  
    }  
  
    clock_t finish = clock();  
  
    cout << "\n\n" << "运行时间： " << (double)(finish-start)*1000/CLOCKS_PER_SEC<< " ms" << endl;  
  
    return 0;  
}

```

```cpp
/*********************golay.h*********************/  
  
#include <iostream>  
#include <vector>  
#include <math.h>  
#include <time.h>  
#include <string>  
  
using namespace std;  
  
class matrix  
{  
public:  
    int row;  
    int column;  
    vector < vector <int> > m;  
  
    matrix() {};  
    matrix(int r, int c)  
    {  
        row = r;  
        column = c;  
  
        for (int i = 0; i < r; i++)  
        {  
            m.push_back(vector<int>());  
        }  
  
        for (int j = 0; j < c; j++)  
        {  
            for (int i = 0; i < m.size(); i++)  
            {  
                m[i].push_back(0);  
            }  
        }  
    }  
};  
  
// 矩阵乘法  
matrix multiply(matrix a, matrix b);  
// 打印矩阵  
void print(matrix a);  
// 转置矩阵  
matrix transpose(matrix a);  
// 生成Golay码的生成矩阵  
matrix golay_generator();  
// 生成B矩阵  
matrix generate_B();  
// 生成单位矩阵  
matrix generate_I(int a);  
// 矩阵加法  
matrix addition(matrix a, matrix b);  
// 生成消息  
matrix generate_message();  
// 编码  
matrix encode(matrix m);  
// 产生噪声  
matrix noisy_channel(matrix m);  
// 权重  
int weight(matrix a);  
  
// 矩阵乘法  
matrix multiply(matrix a, matrix b)  
{  
    int i,j,k,l;  
    int tem = 0;  
    int index = 0;  
    matrix temp(a.row , b.column);  
  
    if (a.column != b.row)  
    {  
        cout << "错误：无法相乘这两个矩阵";  
    }  
    else  
    {  
        for(i = 0 ; i < a.row ; i++)  
        {  
            for(j = 0; j < b.column ; j++)  
            {  
                for(k = 0 ; k < a.column ; k++)  
                {  
                    tem = a.m[i][k] * b.m[k][j];  
                    index = index + tem;  
                    tem = 0;  
                }  
  
                temp.m[i][j] = index % 2;  
                index = 0;  
            }  
        }  
    }  
  
    return temp;  
}  
  
// 矩阵加法  
matrix addition(matrix a, matrix b)  
{  
    matrix temp(a.row, a.column);  
    int i,j;  
  
    if(a.row != b.row || a.column != b.column)  
    {  
        cout << "错误：无法相加这两个矩阵";  
    }  
    else  
    {  
        for(i = 0 ; i < a.row ; i++)  
        {  
            for(j = 0 ; j < a.column ; j++)  
            {  
                temp.m[i][j] = (a.m[i][j] + b.m[i][j]) % 2;  
            }  
        }  
    }  
  
    return temp;  
}  
  
// 矩阵转置  
matrix transpose(matrix a)  
{  
    matrix temp(a.column , a.row);  
    int i, j;  
  
    for(i = 0; i < a.row ; i++)  
    {  
        for(j = 0 ; j < a.column ; j++)  
        {  
            temp.m[j][i] = a.m[i][j];  
        }  
    }  
  
    return temp;  
}  
  
// 打印矩阵  
void print(matrix a)  
{  
    int i,j;  
  
    for (i = 0 ; i < a.row ; i++)  
    {  
        for (j = 0 ; j < a.column ; j++)  
        {  
  
            cout << a.m[i][j] << "  ";  
        }  
  
        cout << endl;  
    }  
}  
  
// 生成Golay码的生成矩阵  
matrix golay_generator()  
{  
    matrix generator(12,24);  
    int i, j, k;  
    int check = 0;  
    int count = 1;  
    vector<int> squares(1);  
  
    for(i = 0 ; i < 12 ; i++)  
    {  
        generator.m[i][i] = 1;  
    }  
  
    for(i = 0 ; i < 11 ; i++)  
    {  
        generator.m[i][12] = 1;  
    }  
  
    for(i = 13 ; i < 24 ; i++)  
    {  
        generator.m[11][i] = 1;  
    }  
  
    for(i = 0 ; i < 11 ; i++)  
    {  
        j = (i*i) % 11;  
  
        for(k = 0; k < squares.size() ; k++)  
        {  
            if(j == squares[k])  
            {  
                check = 1;  
            }  
  
        }  
  
        if(check == 0)  
        {  
            squares.push_back(j);  
        }  
  
        check = 0;  
    }  
  
    for(i = 0 ; i < squares.size() ; i++)  
    {  
        squares[i] = squares[i] + 13;  
    }  
  
    for(i = 13 ; i < 24 ; i++)  
    {  
        for(j = 0 ; j < squares.size() ; j++)  
        {  
            if(squares[j] == i)  
            {  
                generator.m[0][i] = 1;  
            }  
        }  
    }  
  
    while(count != 11)  
    {  
        for(i = 0 ; i < squares.size() ; i++)  
        {  
            squares[i] = ((squares[i] - 12) % 11) + 13;  
        }  
  
        for(i = 13 ; i < 24 ; i++)  
        {  
            for(j = 0 ; j < squares.size() ; j++)  
            {  
                if(squares[j] == i)  
                {  
                    generator.m[count][i] = 1;  
                }  
            }  
        }  
  
        count++;  
    }  
  
    return generator;  
}  
  
// 生成B矩阵  
matrix generate_B()  
{  
    matrix generator(12,12);  
    int i, j, k;  
    int count = 1;  
    int check = 0;  
    vector<int> squares;  
  
    for(i = 0 ; i < 11 ; i++)  
    {  
        generator.m[i][0] = 1;  
    }  
  
    for(i = 1 ; i < 12 ; i++)  
    {  
        generator.m[11][i] = 1;  
    }  
  
    for(i = 0 ; i < 11 ; i++)  
    {  
        j = (i*i) % 11;  
  
        for(k = 0; k < squares.size() ; k++)  
        {  
            if(j == squares[k])  
            {  
                check = 1;  
            }  
  
        }  
  
        if(check == 0)  
        {  
            squares.push_back(j);  
        }  
  
        check = 0;  
    }  
  
    for(i = 0 ; i < squares.size() ; i++)  
    {  
        squares[i] = squares[i] + 1;  
    }  
  
    for(i = 0 ; i < 12 ; i++)  
    {  
        for(j = 0 ; j < squares.size() ; j++)  
        {  
            if(squares[j] == i)  
            {  
                generator.m[0][i] = 1;  
            }  
        }  
    }  
  
    while(count != 11)  
    {  
        for(i = 0 ; i < squares.size() ; i++)  
        {  
            squares[i] = (squares[i] % 11) + 1;  
  
  
        }  
  
        for(i = 1 ; i < 12 ; i++)  
        {  
            for(j = 0 ; j < squares.size() ; j++)  
            {  
                if(squares[j] == i)  
                {  
                    generator.m[count][i] = 1;  
                }  
            }  
        }  
  
        count++;  
    }  
  
    return generator;  
}  
  
// 生成单位矩阵  
matrix generate_I(int a)  
{  
    matrix temp(a,a);  
    int i;  
  
    for(i = 0 ; i < a ; i++)  
    {  
        temp.m[i][i] = 1;  
    }  
  
    return temp;  
}  
  
// 生成消息  
matrix generate_message()  
{  
    matrix message(1,12);  
    int i,temp;  
  
    srand (time(NULL));  
  
    for(i = 0 ; i < 12 ; i++)  
    {  
        temp = rand()%2;  
        message.m[0][i] = temp;  
    }  
  
    return message;  
}  
  
// 编码  
matrix encode(matrix m, matrix G)  
{  
    matrix temp = multiply(m,G);  
  
    return temp;  
}  
  
// 产生噪声  
matrix noisy_channel(matrix m)  
{  
    int i = 0;  
    int r;  
    int errors = 0;  
    matrix temp = m;  
  
    srand (time(NULL));  
  
    while(errors != 3 && i != temp.m[0].size())  
    {  
  
        r = rand()%100;  
  
        if(r >= 25 && r <= 35)  
        {  
            temp.m[0][i] = (temp.m[0][i] + 1) % 2;  
  
            errors++;  
        }  
  
        i++;  
    }  
  
    cout << endl << "传输过程中的错误数量为：" << errors << endl;  
  
    return temp;  
}  
  
// 权重  
int weight(matrix a)  
{  
    int temp = 0;  
    int i;  
  
    for(i = 0 ; i < a.m[0].size() ; i++)  
    {  
        if(a.m[0][i] == 1)  
        {  
            temp++;  
        }  
    }  
  
    return temp;  
}
```
## 参考

本页面部分内容译自博文 [Код Грея](http://e-maxx.ru/algo/gray_code) 与其英文翻译版 [Gray code](https://cp-algorithms.com/algebra/gray-code.html)。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。

[Using The Golay Error Detection And Correction Code | Atlantic Quality Design, Inc. R&D Services (aqdi.com)](https://aqdi.com/articles/using-the-golay-error-detection-and-correction-code-3/)